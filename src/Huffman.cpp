#include <unordered_map>
#include <iostream>
#include <string>
#include <queue>

using namespace std;

struct Node
{
    char c;
    int frequency;
    Node *left;
    Node *right;
};

Node* createNode(char c, int frequency, Node* left, Node* right){
    Node* node = new Node();

    node->c = c;
    node->frequency = frequency;
    node->left = left;
    node->right = right;

    return node;
}

// Comparison object
struct comparison
{
    bool operator()(const Node* left, const Node* right) const{
        return left->frequency > right->frequency;
    }
};

bool isLeaf(Node* node){
    if (node->left == nullptr){
        if (node->right == nullptr){
            return true;
        }
    }
    return false;
}

// Stores the code for each character generated by the Huffman tree in a map.
void encode(Node* root, string code, unordered_map<char, string> &huffmanCode){
    if (root == nullptr){
        return;
    }

    if (isLeaf(root)){
        char key = root->c;
        if (code != ""){
            huffmanCode[key] = code;
        } else {
            huffmanCode[key] = "1";
        }
    }

    encode(root->left, (code + "0"), huffmanCode);
    encode(root->right, (code + "1"), huffmanCode);
}

// Uses the huffman tree to decode an encoded text.
string decode(Node* root, int &index, string encodedText){
    string decodedText = "";

    if (root != nullptr){
        if (isLeaf(root)){
            decodedText.push_back(root->c);
            return decodedText;
        }

        index++;

        if (encodedText[index] == '0'){
            decodedText.append(decode(root->left, index, encodedText));
        } else {
            decodedText.append(decode(root->right, index, encodedText));
        }
    }

    return decodedText;
}

// Builds the huffman tree and 
void buildHuffmanTree(string text){
    if (text == ""){
        return;
    }

    // counts the frequency of each character in the text.
    unordered_map<char, int> frequency;
    for (char c : text){
        frequency[c] += 1;
    }

    // Creates a priority queue to store the nodes of the in-progress huffman tree.
    // And for each character present in the text at least once, create a node and
    // put it at the queue.
    priority_queue<Node*, vector<Node*>, comparison> queue;

    for (auto pair: frequency) {
        queue.push(
            createNode(pair.first, pair.second, nullptr, nullptr)
        );
    }

    while (queue.size() != 1){
        // removes the 2 nodes with the lowest frequency from the queue and
        // merge them, making a new node whose children are the 2 previous nodes.
        // The new node frequency is the sum of the previous 2 frequencies.
        Node* left = queue.top();
        queue.pop();
        Node* right = queue.top();
        queue.pop();

        queue.push(
            createNode('\0', (left->frequency + right->frequency), left, right)
        );
    }

    Node* huffmanTreeRoot = queue.top();

    // Store the codes
    unordered_map<char, string> huffmanCode;
    encode(huffmanTreeRoot, "", huffmanCode);

    cout << "Huffman Codes are:\n" << endl;
    for (auto pair: huffmanCode) {
        cout << pair.first << " " << pair.second << endl;
    }
 
    cout << "\nThe original string is:\n" << text << endl;

    string encodedString = "";
    for (char c : text){
        encodedString.append(
            huffmanCode[c]
        );
    }

    cout << "\nThe encoded string is:\n" << encodedString << endl;

    string decodedString = "";

    if (isLeaf(huffmanTreeRoot)){
        // Special case: A string with only one character repeated any number of times.
        while(huffmanTreeRoot->frequency--){
            decodedString.push_back(huffmanTreeRoot->c);
        }
    } else {
        int index = -1;
        while (index < (int)encodedString.size() - 1){
            decodedString.append(
                decode(huffmanTreeRoot, index, encodedString)
            );
        }
    }

    cout << "\nThe decoded string is:\n" << decodedString << endl;
}

int main(){
    string text = "Huffman coding is a data compression algorithm.";
    buildHuffmanTree(text);

    return 0;
}

// TODO
// 1. serialize tree struct
// 2. save the encoded text as an array of bits of some sort, instead of string.
// 3. save serialized tree and bits array to a file, so that they can be easily restored later.
// 4. wrapper functions for compressing and decompressing files. 