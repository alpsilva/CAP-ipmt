#include <unordered_map>
#include <iostream>
#include <fstream>
#include <string>
#include <queue>

using namespace std;

struct Node
{
    char c;
    int frequency;
    Node *left;
    Node *right;
};

Node* createNode(char c, int frequency, Node* left, Node* right){
    Node* node = new Node();

    node->c = c;
    node->frequency = frequency;
    node->left = left;
    node->right = right;

    return node;
}

// Comparison object
struct comparison
{
    bool operator()(const Node* left, const Node* right) const{
        return left->frequency > right->frequency;
    }
};

bool isLeaf(Node* node){
    if (node->left == nullptr){
        if (node->right == nullptr){
            return true;
        }
    }
    return false;
}

// Stores the code for each character generated by the Huffman tree in a map.
void encode(Node* root, string code, unordered_map<char, string> &huffmanCode){
    if (root == nullptr){
        return;
    }

    if (isLeaf(root)){
        char key = root->c;
        if (code != ""){
            huffmanCode[key] = code;
        } else {
            huffmanCode[key] = "1";
        }
    }

    encode(root->left, (code + "0"), huffmanCode);
    encode(root->right, (code + "1"), huffmanCode);
}

// Uses the huffman tree to decode an encoded text.
string decode(Node* root, int &index, string encodedText){
    string decodedText = "";

    if (root != nullptr){
        if (isLeaf(root)){
            decodedText.push_back(root->c);
            return decodedText;
        }

        index++;

        if (encodedText[index] == '0'){
            decodedText.append(decode(root->left, index, encodedText));
        } else {
            decodedText.append(decode(root->right, index, encodedText));
        }
    }

    return decodedText;
}

// Builds the huffman tree and 
string buildHuffmanTree(string text){
    if (text == ""){
        return "";
    }

    // counts the frequency of each character in the text.
    unordered_map<char, int> frequency;
    for (char c : text){
        frequency[c] += 1;
    }

    // Creates a priority queue to store the nodes of the in-progress huffman tree.
    // And for each character present in the text at least once, create a node and
    // put it at the queue.
    priority_queue<Node*, vector<Node*>, comparison> queue;

    for (auto pair: frequency) {
        queue.push(
            createNode(pair.first, pair.second, nullptr, nullptr)
        );
    }

    while (queue.size() != 1){
        // removes the 2 nodes with the lowest frequency from the queue and
        // merge them, making a new node whose children are the 2 previous nodes.
        // The new node frequency is the sum of the previous 2 frequencies.
        Node* left = queue.top();
        queue.pop();
        Node* right = queue.top();
        queue.pop();

        queue.push(
            createNode('\0', (left->frequency + right->frequency), left, right)
        );
    }

    Node* huffmanTreeRoot = queue.top();

    // Store the codes
    unordered_map<char, string> huffmanCode;
    encode(huffmanTreeRoot, "", huffmanCode);

    cout << "Huffman Codes are:\n" << endl;
    for (auto pair: huffmanCode) {
        cout << pair.first << " " << pair.second << endl;
    }
 
    cout << "\nThe original string is:\n" << text << endl;

    string encodedString = "";
    for (char c : text){
        encodedString.append(
            huffmanCode[c]
        );
    }

    cout << "\nThe encoded string is:\n" << encodedString << endl;

    string decodedString = "";

    if (isLeaf(huffmanTreeRoot)){
        // Special case: A string with only one character repeated any number of times.
        while(huffmanTreeRoot->frequency--){
            decodedString.push_back(huffmanTreeRoot->c);
        }
    } else {
        int index = -1;
        while (index < (int)encodedString.size() - 1){
            decodedString.append(
                decode(huffmanTreeRoot, index, encodedString)
            );
        }
    }

    cout << "\nThe decoded string is:\n" << decodedString << endl;

    return encodedString;
}

void writeCodeInBits(string filePath, string encodedText){
    // As we can't write individual bits to files, we arrange them in groups of 8
    // and write the bytes.
    int byte_index = 0;
    unsigned char bit_buffer;

    FILE *file;
    file = fopen(filePath.c_str(), "w");

    if (file == NULL){
        cout << "Error opening file." << endl;
    }

    for (char c : encodedText){
        int bit = c - '0';
        if (bit){
            bit_buffer |= (1<<byte_index);
        }
        byte_index++;
        if (byte_index == 8){
            fwrite (&bit_buffer, 1, 1, file);
            byte_index = 0;
            bit_buffer = 0;
        }
    }

    // TODO: There will be a small amount of bits left to process, deal with it.
    fclose (file);
}

string readCodeInBits(string filePath){
    ifstream file;
    file.open(filePath, ios::binary | ios::in);

    string text = "";

    char c;
    while (file.get(c)){
        for (int i = 0; i < 8; i++){
            int bit = (c >> i) & 1;
            text.push_back(bit + '0');
        }
    }
    return text;
}

int main(){
    string text = "Huffman coding is a data compression algorithm.";
    string encoded = buildHuffmanTree(text);
    string filePath = "file.bin";

    writeCodeInBits(filePath, encoded);
    string readText = readCodeInBits(filePath);
    cout << readText << endl;

    return 0;
}

// TODO
// 1. serialize tree struct
// 2. save the encoded text as an array of bits of some sort, instead of string.
// 3. save serialized tree and bits array to a file, so that they can be easily restored later.
// 4. wrapper functions for compressing and decompressing files. 